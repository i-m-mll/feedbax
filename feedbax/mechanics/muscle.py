"""Muscle models.

TODO:
- Multiplicative noise option
- Static element (SE) model
- Y and l_eff filters. See `_Y_field` and `_l_eff_field` methods.
    - None of the simplified models I've cited implement these.

:copyright: Copyright 2023-2024 by MLL <mll@mll.bio>.
:license: Apache 2.0, see LICENSE for details.
"""

from __future__ import annotations

from abc import abstractmethod
from collections.abc import Callable
import logging
from typing import Optional, Tuple

import equinox as eqx
from equinox import Module, field
import jax
import jax.numpy as jnp
import jax.random as jr
import jax.tree as jt
from jaxtyping import Array, ArrayLike, Float, PRNGKeyArray, PyTree, Scalar
import numpy as np

from feedbax.dynamics import AbstractDynamicalSystem
from feedbax.state import StateBounds


logger = logging.getLogger(__name__)


class MuscleState(Module):
    """State for muscle models.

    Attributes:
        activation: The muscle activation.
        length: The muscle length.
        velocity: The muscle contraction velocity.
        tension: The tensile force generated by the muscle.
    """

    activation: Array
    length: Array
    velocity: Array
    tension: Array


class AbstractFLVFunction(eqx.Module):
    """Base class for muscle force (force-length-velocity) functions."""

    @abstractmethod
    def __call__(self, input: Array, state: MuscleState, key: PRNGKeyArray) -> Array:
        ...


class AbstractActivationFunction(eqx.Module):
    """Base class for muscle activation functions."""

    @abstractmethod
    def __call__(self, input: Array, state: MuscleState, key: PRNGKeyArray) -> Array:
        ...


class AbstractMuscle(eqx.Module):
    """Base class for muscle models."""

    n_muscles: int
    activation_func: AbstractActivationFunction
    force_func: AbstractFLVFunction
    noise_func: Optional[Callable[[Array, Array, Array], Array]] = None

    def __call__(
        self,
        input: Array,
        state: MuscleState,
        *,
        key: PRNGKeyArray,
    ) -> MuscleState:
        activation = self.activation_func(input, state, key=key)
        state = eqx.tree_at(lambda s: s.activation, state, activation)
        tension = self.force_func(activation, state, key=key)
        state = eqx.tree_at(lambda s: s.tension, state, tension)
        return state

    def change_n_muscles(self, n_muscles: int) -> "AbstractMuscle":
        return eqx.tree_at(lambda m: m.n_muscles, self, n_muscles)


class VirtualMuscle(AbstractMuscle):
    """Implements the Virtual Muscle Model from Brown et al. 1999."""

    n_muscles: int
    activation_func: AbstractActivationFunction
    force_func: AbstractFLVFunction
    noise_func: Optional[Callable[[Array, Array, Array], Array]] = None

    def init(self, *, key: PRNGKeyArray) -> MuscleState:
        state = MuscleState(
            activation=jnp.zeros(self.n_muscles),
            length=jnp.ones(self.n_muscles),
            velocity=jnp.zeros(self.n_muscles),
            tension=jnp.zeros(self.n_muscles),
        )
        return self(state.activation, state, key=key)

    @property
    def bounds(self) -> StateBounds[MuscleState]:
        if isinstance(self.activation_func, VirtualMuscleActivationFunction):
            n_f = self.activation_func.n_f
            length_ub = 0.95 * n_f[1] / (n_f[1] - n_f[0])
        else:
            length_ub = None

        return StateBounds(
            low=MuscleState(
                activation=0.0,
                length=None,
                velocity=None,
                tension=None,
            ),
            high=MuscleState(
                activation=None,
                length=length_ub,
                velocity=None,
                tension=None,
            ),
        )


class AbstractForceFunction(eqx.Module):
    @abstractmethod
    def __call__(self, length: Array, velocity: Array) -> Array:
        ...


class VirtualMuscleForceLength(AbstractForceFunction):
    beta: float
    omega: float
    rho: float

    def __call__(self, length: Array, velocity: Array) -> Array:
        return jnp.exp(-jnp.abs((length**self.beta - 1) / self.omega) ** self.rho)


class AbstractVirtualMuscleShortenFactor(eqx.Module):
    c_v: Tuple[float, float] = field(converter=tuple)

    @abstractmethod
    def __call__(self, length: Array) -> ArrayLike:
        ...


class VirtualMuscleShortenFactor(AbstractVirtualMuscleShortenFactor):
    def __call__(self, length: Array) -> ArrayLike:
        return self.c_v[0] + self.c_v[1] * length


class HillShortenFactor(AbstractVirtualMuscleShortenFactor):
    def __call__(self, length: Array) -> ArrayLike:
        return self.c_v[0] + self.c_v[1]


class VirtualMuscleForceVelocity(AbstractForceFunction):
    a_v: Tuple[float, float, float]
    b_v: float
    v_max: float
    shorten_denom_factor_func: AbstractVirtualMuscleShortenFactor

    def __call__(self, length: Array, velocity: Array) -> Array:
        f_lengthen = (
            self.b_v
            - velocity * (self.a_v[0] + self.a_v[1] * length + self.a_v[2] * length**2)
        ) / (self.b_v + velocity)
        f_shorten = (
            self.v_max - velocity
        ) / (
            self.v_max
            + velocity * self.shorten_denom_factor_func(length)
        )
        return jnp.where(velocity >= 0, f_shorten, f_lengthen)


class VirtualMuscleForcePassive(AbstractForceFunction):
    beta: float
    omega: float
    rho: float
    k: float
    l_max: float

    def __call__(self, length: Array, velocity: Array) -> Array:
        return self.k * (
            jnp.exp(-jnp.abs((length / self.l_max) ** self.beta - 1) / self.omega) ** self.rho
        )


class VirtualMuscleForce(AbstractFLVFunction):
    f0: float
    f_active: AbstractForceFunction
    f_passive: AbstractForceFunction

    def __call__(self, input: Array, state: MuscleState, key: PRNGKeyArray) -> Array:
        f_active = self.f_active(state.length, state.velocity)
        f_passive = self.f_passive(state.length, state.velocity)
        return self.f0 * (f_active * input + f_passive)


class VirtualMuscleActivationFunction(AbstractActivationFunction):
    """Activation function from Brown et al. 1999."""

    n_f: Tuple[float, float] = field(converter=tuple)
    g_f: float
    f_a: float
    t_a: float

    def __call__(self, input: Array, state: MuscleState, key: PRNGKeyArray) -> Array:
        activation = (input**self.g_f) / (input**self.g_f + self.n_f[0] ** self.g_f)
        return activation


class HillActivationFunction(AbstractActivationFunction):
    def __call__(self, input: Array, state: MuscleState, key: PRNGKeyArray) -> Array:
        return input


class ActivationFilter(AbstractDynamicalSystem[Array]):
    """Low-pass filter for muscle activation."""

    tau_act: float
    tau_deact: float

    def vector_field(self, t: Scalar, state: Array, input: Array) -> Array:
        tau = jnp.where(input > state, self.tau_act, self.tau_deact)
        return (input - state) / tau

    def init(self, *, key: PRNGKeyArray) -> Array:
        return jnp.zeros(())

    @property
    def input_size(self) -> int:
        return 1
