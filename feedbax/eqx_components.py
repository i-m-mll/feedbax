"""Auto-generated Equinox component wrappers.

This file is generated by scripts/generate_eqx_components.py.
Do not edit manually - regenerate instead.

To regenerate:
    uv run scripts/generate_eqx_components.py
"""

from __future__ import annotations

from collections.abc import Hashable
from typing import Any, Callable, Literal, Optional, Sequence, Union

import jax
import equinox as eqx
from equinox.nn import State
from jaxtyping import PRNGKeyArray, PyTree

from feedbax.graph import Component


__all__ = [
    "Linear",
    "Identity",
    "MLP",
    "Conv1d",
    "Conv2d",
    "Conv3d",
    "ConvTranspose1d",
    "ConvTranspose2d",
    "ConvTranspose3d",
    "GRUCell",
    "LSTMCell",
    "LayerNorm",
    "RMSNorm",
    "GroupNorm",
    "BatchNorm",
    "MaxPool1d",
    "MaxPool2d",
    "MaxPool3d",
    "AvgPool1d",
    "AvgPool2d",
    "AvgPool3d",
    "AdaptiveMaxPool1d",
    "AdaptiveMaxPool2d",
    "AdaptiveMaxPool3d",
    "AdaptiveAvgPool1d",
    "AdaptiveAvgPool2d",
    "AdaptiveAvgPool3d",
    "MultiheadAttention",
    "RotaryPositionalEmbedding",
    "Embedding",
    "Dropout",
    "PReLU",
]

# ============================================================
# LINEAR LAYERS
# ============================================================

class Linear(Component):
    """Linear transformation layer."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.Linear
    in_features: Union[int, Literal['scalar']]
    out_features: Union[int, Literal['scalar']]
    use_bias: bool
    dtype: Any
    def __init__(self, in_features: Union[int, Literal['scalar']], out_features: Union[int, Literal['scalar']], use_bias: bool = True, dtype = None, *, key: PRNGKeyArray):
        self.in_features = in_features
        self.out_features = out_features
        self.use_bias = use_bias
        self.dtype = dtype
        self.layer = eqx.nn.Linear(in_features=in_features, out_features=out_features, use_bias=use_bias, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class Identity(Component):
    """Identity layer (passes input through unchanged)."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.Identity

    def __init__(self):

        self.layer = eqx.nn.Identity()

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class MLP(Component):
    """Multi-layer perceptron with configurable depth and activations."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.MLP
    in_size: Union[int, Literal['scalar']]
    out_size: Union[int, Literal['scalar']]
    width_size: int
    depth: int
    activation: Callable
    final_activation: Callable
    use_bias: bool
    use_final_bias: bool
    dtype: Any
    def __init__(self, in_size: Union[int, Literal['scalar']], out_size: Union[int, Literal['scalar']], width_size: int, depth: int, activation: Callable = jax.nn.relu, final_activation: Callable = lambda x: x, use_bias: bool = True, use_final_bias: bool = True, dtype = None, *, key: PRNGKeyArray):
        self.in_size = in_size
        self.out_size = out_size
        self.width_size = width_size
        self.depth = depth
        self.activation = activation
        self.final_activation = final_activation
        self.use_bias = use_bias
        self.use_final_bias = use_final_bias
        self.dtype = dtype
        self.layer = eqx.nn.MLP(in_size=in_size, out_size=out_size, width_size=width_size, depth=depth, activation=activation, final_activation=final_activation, use_bias=use_bias, use_final_bias=use_final_bias, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

# ============================================================
# CONV LAYERS
# ============================================================

class Conv1d(Component):
    """1D convolution layer."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.Conv1d
    in_channels: int
    out_channels: int
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]]
    dilation: Union[int, Sequence[int]]
    groups: int
    use_bias: bool
    padding_mode: str
    dtype: Any
    def __init__(self, in_channels: int, out_channels: int, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = 1, padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]] = 0, dilation: Union[int, Sequence[int]] = 1, groups: int = 1, use_bias: bool = True, padding_mode: str = 'ZEROS', dtype = None, *, key: PRNGKeyArray):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.dilation = dilation
        self.groups = groups
        self.use_bias = use_bias
        self.padding_mode = padding_mode
        self.dtype = dtype
        self.layer = eqx.nn.Conv1d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, groups=groups, use_bias=use_bias, padding_mode=padding_mode, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class Conv2d(Component):
    """2D convolution layer."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.Conv2d
    in_channels: int
    out_channels: int
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]]
    dilation: Union[int, Sequence[int]]
    groups: int
    use_bias: bool
    padding_mode: str
    dtype: Any
    def __init__(self, in_channels: int, out_channels: int, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = (1, 1), padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]] = (0, 0), dilation: Union[int, Sequence[int]] = (1, 1), groups: int = 1, use_bias: bool = True, padding_mode: str = 'ZEROS', dtype = None, *, key: PRNGKeyArray):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.dilation = dilation
        self.groups = groups
        self.use_bias = use_bias
        self.padding_mode = padding_mode
        self.dtype = dtype
        self.layer = eqx.nn.Conv2d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, groups=groups, use_bias=use_bias, padding_mode=padding_mode, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class Conv3d(Component):
    """3D convolution layer."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.Conv3d
    in_channels: int
    out_channels: int
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]]
    dilation: Union[int, Sequence[int]]
    groups: int
    use_bias: bool
    padding_mode: str
    dtype: Any
    def __init__(self, in_channels: int, out_channels: int, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = (1, 1, 1), padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]] = (0, 0, 0), dilation: Union[int, Sequence[int]] = (1, 1, 1), groups: int = 1, use_bias: bool = True, padding_mode: str = 'ZEROS', dtype = None, *, key: PRNGKeyArray):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.dilation = dilation
        self.groups = groups
        self.use_bias = use_bias
        self.padding_mode = padding_mode
        self.dtype = dtype
        self.layer = eqx.nn.Conv3d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, stride=stride, padding=padding, dilation=dilation, groups=groups, use_bias=use_bias, padding_mode=padding_mode, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class ConvTranspose1d(Component):
    """1D transposed convolution (deconvolution) layer."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.ConvTranspose1d
    in_channels: int
    out_channels: int
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    output_padding: Union[int, Sequence[int]]
    padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]]
    dilation: Union[int, Sequence[int]]
    groups: int
    use_bias: bool
    padding_mode: str
    dtype: Any
    def __init__(self, in_channels: int, out_channels: int, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = 1, output_padding: Union[int, Sequence[int]] = 0, padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]] = 0, dilation: Union[int, Sequence[int]] = 1, groups: int = 1, use_bias: bool = True, padding_mode: str = 'ZEROS', dtype = None, *, key: PRNGKeyArray):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.output_padding = output_padding
        self.padding = padding
        self.dilation = dilation
        self.groups = groups
        self.use_bias = use_bias
        self.padding_mode = padding_mode
        self.dtype = dtype
        self.layer = eqx.nn.ConvTranspose1d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, stride=stride, output_padding=output_padding, padding=padding, dilation=dilation, groups=groups, use_bias=use_bias, padding_mode=padding_mode, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class ConvTranspose2d(Component):
    """2D transposed convolution (deconvolution) layer."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.ConvTranspose2d
    in_channels: int
    out_channels: int
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    output_padding: Union[int, Sequence[int]]
    padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]]
    dilation: Union[int, Sequence[int]]
    groups: int
    use_bias: bool
    padding_mode: str
    dtype: Any
    def __init__(self, in_channels: int, out_channels: int, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = (1, 1), output_padding: Union[int, Sequence[int]] = (0, 0), padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]] = (0, 0), dilation: Union[int, Sequence[int]] = (1, 1), groups: int = 1, use_bias: bool = True, padding_mode: str = 'ZEROS', dtype = None, *, key: PRNGKeyArray):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.output_padding = output_padding
        self.padding = padding
        self.dilation = dilation
        self.groups = groups
        self.use_bias = use_bias
        self.padding_mode = padding_mode
        self.dtype = dtype
        self.layer = eqx.nn.ConvTranspose2d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, stride=stride, output_padding=output_padding, padding=padding, dilation=dilation, groups=groups, use_bias=use_bias, padding_mode=padding_mode, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class ConvTranspose3d(Component):
    """3D transposed convolution (deconvolution) layer."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.ConvTranspose3d
    in_channels: int
    out_channels: int
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    output_padding: Union[int, Sequence[int]]
    padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]]
    dilation: Union[int, Sequence[int]]
    groups: int
    use_bias: bool
    padding_mode: str
    dtype: Any
    def __init__(self, in_channels: int, out_channels: int, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = (1, 1, 1), output_padding: Union[int, Sequence[int]] = (0, 0, 0), padding: Union[str, int, Sequence[int], Sequence[tuple[int, int]]] = (0, 0, 0), dilation: Union[int, Sequence[int]] = (1, 1, 1), groups: int = 1, use_bias: bool = True, padding_mode: str = 'ZEROS', dtype = None, *, key: PRNGKeyArray):
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.output_padding = output_padding
        self.padding = padding
        self.dilation = dilation
        self.groups = groups
        self.use_bias = use_bias
        self.padding_mode = padding_mode
        self.dtype = dtype
        self.layer = eqx.nn.ConvTranspose3d(in_channels=in_channels, out_channels=out_channels, kernel_size=kernel_size, stride=stride, output_padding=output_padding, padding=padding, dilation=dilation, groups=groups, use_bias=use_bias, padding_mode=padding_mode, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

# ============================================================
# RNN LAYERS
# ============================================================

class GRUCell(Component):
    """Gated Recurrent Unit cell."""

    input_ports = ('input', 'hidden')
    output_ports = ('output', 'hidden')

    layer: eqx.nn.GRUCell
    input_size: int
    hidden_size: int
    use_bias: bool
    dtype: Any
    def __init__(self, input_size: int, hidden_size: int, use_bias: bool = True, dtype = None, *, key: PRNGKeyArray):
        self.input_size = input_size
        self.hidden_size = hidden_size
        self.use_bias = use_bias
        self.dtype = dtype
        self.layer = eqx.nn.GRUCell(input_size=input_size, hidden_size=hidden_size, use_bias=use_bias, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        hidden = inputs["hidden"]
        new_hidden = self.layer(inputs["input"], hidden)
        return {"output": new_hidden, "hidden": new_hidden}, state

class LSTMCell(Component):
    """Long Short-Term Memory cell."""

    input_ports = ('input', 'hidden', 'cell')
    output_ports = ('output', 'hidden', 'cell')

    layer: eqx.nn.LSTMCell
    input_size: int
    hidden_size: int
    use_bias: bool
    dtype: Any
    def __init__(self, input_size: int, hidden_size: int, use_bias: bool = True, dtype = None, *, key: PRNGKeyArray):
        self.input_size = input_size
        self.hidden_size = hidden_size
        self.use_bias = use_bias
        self.dtype = dtype
        self.layer = eqx.nn.LSTMCell(input_size=input_size, hidden_size=hidden_size, use_bias=use_bias, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        hidden = inputs["hidden"]
        cell_state = inputs["cell"]
        new_hidden, new_cell = self.layer(inputs["input"], hidden, cell_state)
        return {"output": new_hidden, "hidden": new_hidden, "cell": new_cell}, state

# ============================================================
# NORM LAYERS
# ============================================================

class LayerNorm(Component):
    """Layer normalization."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.LayerNorm
    shape: Union[int, Sequence[int]]
    eps: float
    use_weight: bool
    use_bias: bool
    dtype: Any
    elementwise_affine: Optional[bool]
    def __init__(self, shape: Union[int, Sequence[int]], eps: float = 1e-05, use_weight: bool = True, use_bias: bool = True, dtype = None, elementwise_affine: Optional[bool] = None):
        self.shape = shape
        self.eps = eps
        self.use_weight = use_weight
        self.use_bias = use_bias
        self.dtype = dtype
        self.elementwise_affine = elementwise_affine
        self.layer = eqx.nn.LayerNorm(shape=shape, eps=eps, use_weight=use_weight, use_bias=use_bias, dtype=dtype, elementwise_affine=elementwise_affine)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class RMSNorm(Component):
    """Root Mean Square normalization."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.RMSNorm
    shape: Union[int, Sequence[int]]
    eps: float
    use_weight: bool
    use_bias: bool
    dtype: Any
    def __init__(self, shape: Union[int, Sequence[int]], eps: float = 1e-05, use_weight: bool = True, use_bias: bool = True, dtype = None):
        self.shape = shape
        self.eps = eps
        self.use_weight = use_weight
        self.use_bias = use_bias
        self.dtype = dtype
        self.layer = eqx.nn.RMSNorm(shape=shape, eps=eps, use_weight=use_weight, use_bias=use_bias, dtype=dtype)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class GroupNorm(Component):
    """Group normalization."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.GroupNorm
    groups: int
    channels: Optional[int]
    eps: float
    channelwise_affine: bool
    dtype: Any
    def __init__(self, groups: int, channels: Optional[int] = None, eps: float = 1e-05, channelwise_affine: bool = True, dtype = None):
        self.groups = groups
        self.channels = channels
        self.eps = eps
        self.channelwise_affine = channelwise_affine
        self.dtype = dtype
        self.layer = eqx.nn.GroupNorm(groups=groups, channels=channels, eps=eps, channelwise_affine=channelwise_affine, dtype=dtype)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class BatchNorm(Component):
    """Batch normalization. Uses inference mode by default in graph execution."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.BatchNorm
    input_size: int
    axis_name: Union[Hashable, Sequence[Hashable]]
    eps: float
    channelwise_affine: bool
    momentum: float
    inference: bool
    dtype: Any
    def __init__(self, input_size: int, axis_name: Union[Hashable, Sequence[Hashable]], eps: float = 1e-05, channelwise_affine: bool = True, momentum: float = 0.99, inference: bool = False, dtype = None):
        self.input_size = input_size
        self.axis_name = axis_name
        self.eps = eps
        self.channelwise_affine = channelwise_affine
        self.momentum = momentum
        self.inference = inference
        self.dtype = dtype
        self.layer = eqx.nn.BatchNorm(input_size=input_size, axis_name=axis_name, eps=eps, channelwise_affine=channelwise_affine, momentum=momentum, inference=inference, dtype=dtype)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = eqx.nn.inference_mode(self.layer)(inputs["input"])
        return {"output": output}, state

# ============================================================
# POOL LAYERS
# ============================================================

class MaxPool1d(Component):
    """1D max pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.MaxPool1d
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[int, Sequence[int], Sequence[tuple[int, int]]]
    use_ceil: bool
    def __init__(self, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = 1, padding: Union[int, Sequence[int], Sequence[tuple[int, int]]] = 0, use_ceil: bool = False):
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.use_ceil = use_ceil
        self.layer = eqx.nn.MaxPool1d(kernel_size=kernel_size, stride=stride, padding=padding, use_ceil=use_ceil)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class MaxPool2d(Component):
    """2D max pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.MaxPool2d
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[int, Sequence[int], Sequence[tuple[int, int]]]
    use_ceil: bool
    def __init__(self, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = 1, padding: Union[int, Sequence[int], Sequence[tuple[int, int]]] = 0, use_ceil: bool = False):
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.use_ceil = use_ceil
        self.layer = eqx.nn.MaxPool2d(kernel_size=kernel_size, stride=stride, padding=padding, use_ceil=use_ceil)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class MaxPool3d(Component):
    """3D max pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.MaxPool3d
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[int, Sequence[int], Sequence[tuple[int, int]]]
    use_ceil: bool
    def __init__(self, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = 1, padding: Union[int, Sequence[int], Sequence[tuple[int, int]]] = 0, use_ceil: bool = False):
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.use_ceil = use_ceil
        self.layer = eqx.nn.MaxPool3d(kernel_size=kernel_size, stride=stride, padding=padding, use_ceil=use_ceil)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AvgPool1d(Component):
    """1D average pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AvgPool1d
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[int, Sequence[int], Sequence[tuple[int, int]]]
    use_ceil: bool
    def __init__(self, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = 1, padding: Union[int, Sequence[int], Sequence[tuple[int, int]]] = 0, use_ceil: bool = False):
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.use_ceil = use_ceil
        self.layer = eqx.nn.AvgPool1d(kernel_size=kernel_size, stride=stride, padding=padding, use_ceil=use_ceil)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AvgPool2d(Component):
    """2D average pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AvgPool2d
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[int, Sequence[int], Sequence[tuple[int, int]]]
    use_ceil: bool
    def __init__(self, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = 1, padding: Union[int, Sequence[int], Sequence[tuple[int, int]]] = 0, use_ceil: bool = False):
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.use_ceil = use_ceil
        self.layer = eqx.nn.AvgPool2d(kernel_size=kernel_size, stride=stride, padding=padding, use_ceil=use_ceil)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AvgPool3d(Component):
    """3D average pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AvgPool3d
    kernel_size: Union[int, Sequence[int]]
    stride: Union[int, Sequence[int]]
    padding: Union[int, Sequence[int], Sequence[tuple[int, int]]]
    use_ceil: bool
    def __init__(self, kernel_size: Union[int, Sequence[int]], stride: Union[int, Sequence[int]] = 1, padding: Union[int, Sequence[int], Sequence[tuple[int, int]]] = 0, use_ceil: bool = False):
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.use_ceil = use_ceil
        self.layer = eqx.nn.AvgPool3d(kernel_size=kernel_size, stride=stride, padding=padding, use_ceil=use_ceil)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AdaptiveMaxPool1d(Component):
    """1D adaptive max pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AdaptiveMaxPool1d
    target_shape: Union[int, Sequence[int]]
    def __init__(self, target_shape: Union[int, Sequence[int]]):
        self.target_shape = target_shape
        self.layer = eqx.nn.AdaptiveMaxPool1d(target_shape=target_shape)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AdaptiveMaxPool2d(Component):
    """2D adaptive max pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AdaptiveMaxPool2d
    target_shape: Union[int, Sequence[int]]
    def __init__(self, target_shape: Union[int, Sequence[int]]):
        self.target_shape = target_shape
        self.layer = eqx.nn.AdaptiveMaxPool2d(target_shape=target_shape)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AdaptiveMaxPool3d(Component):
    """3D adaptive max pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AdaptiveMaxPool3d
    target_shape: Union[int, Sequence[int]]
    def __init__(self, target_shape: Union[int, Sequence[int]]):
        self.target_shape = target_shape
        self.layer = eqx.nn.AdaptiveMaxPool3d(target_shape=target_shape)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AdaptiveAvgPool1d(Component):
    """1D adaptive average pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AdaptiveAvgPool1d
    target_shape: Union[int, Sequence[int]]
    def __init__(self, target_shape: Union[int, Sequence[int]]):
        self.target_shape = target_shape
        self.layer = eqx.nn.AdaptiveAvgPool1d(target_shape=target_shape)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AdaptiveAvgPool2d(Component):
    """2D adaptive average pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AdaptiveAvgPool2d
    target_shape: Union[int, Sequence[int]]
    def __init__(self, target_shape: Union[int, Sequence[int]]):
        self.target_shape = target_shape
        self.layer = eqx.nn.AdaptiveAvgPool2d(target_shape=target_shape)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class AdaptiveAvgPool3d(Component):
    """3D adaptive average pooling."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.AdaptiveAvgPool3d
    target_shape: Union[int, Sequence[int]]
    def __init__(self, target_shape: Union[int, Sequence[int]]):
        self.target_shape = target_shape
        self.layer = eqx.nn.AdaptiveAvgPool3d(target_shape=target_shape)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

# ============================================================
# ATTENTION LAYERS
# ============================================================

class MultiheadAttention(Component):
    """Multi-head attention layer."""

    input_ports = ('query', 'key_', 'value')
    output_ports = ('output',)

    layer: eqx.nn.MultiheadAttention
    num_heads: int
    query_size: int
    key_size: Optional[int]
    value_size: Optional[int]
    output_size: Optional[int]
    qk_size: Optional[int]
    vo_size: Optional[int]
    use_query_bias: bool
    use_key_bias: bool
    use_value_bias: bool
    use_output_bias: bool
    dropout_p: float
    inference: bool
    dtype: Any
    def __init__(self, num_heads: int, query_size: int, key_size: Optional[int] = None, value_size: Optional[int] = None, output_size: Optional[int] = None, qk_size: Optional[int] = None, vo_size: Optional[int] = None, use_query_bias: bool = False, use_key_bias: bool = False, use_value_bias: bool = False, use_output_bias: bool = False, dropout_p: float = 0.0, inference: bool = False, dtype = None, *, key: PRNGKeyArray):
        self.num_heads = num_heads
        self.query_size = query_size
        self.key_size = key_size
        self.value_size = value_size
        self.output_size = output_size
        self.qk_size = qk_size
        self.vo_size = vo_size
        self.use_query_bias = use_query_bias
        self.use_key_bias = use_key_bias
        self.use_value_bias = use_value_bias
        self.use_output_bias = use_output_bias
        self.dropout_p = dropout_p
        self.inference = inference
        self.dtype = dtype
        self.layer = eqx.nn.MultiheadAttention(num_heads=num_heads, query_size=query_size, key_size=key_size, value_size=value_size, output_size=output_size, qk_size=qk_size, vo_size=vo_size, use_query_bias=use_query_bias, use_key_bias=use_key_bias, use_value_bias=use_value_bias, use_output_bias=use_output_bias, dropout_p=dropout_p, inference=inference, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(
            query=inputs["query"],
            key_=inputs["key_"],
            value=inputs["value"],
        )
        return {"output": output}, state

class RotaryPositionalEmbedding(Component):
    """Rotary positional embedding for attention."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.RotaryPositionalEmbedding
    embedding_size: int
    theta: float
    dtype: Any
    def __init__(self, embedding_size: int, theta: float = 10000.0, dtype: Any = None):
        self.embedding_size = embedding_size
        self.theta = theta
        self.dtype = dtype
        self.layer = eqx.nn.RotaryPositionalEmbedding(embedding_size=embedding_size, theta=theta, dtype=dtype)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

# ============================================================
# OTHER LAYERS
# ============================================================

class Embedding(Component):
    """Embedding layer for discrete tokens."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.Embedding
    num_embeddings: Optional[int]
    embedding_size: Optional[int]
    weight: Optional[Float[Array, 'num_embeddings embedding_size']]
    dtype: Any
    def __init__(self, num_embeddings: Optional[int] = None, embedding_size: Optional[int] = None, weight: Optional[Float[Array, 'num_embeddings embedding_size']] = None, dtype = None, *, key: PRNGKeyArray):
        self.num_embeddings = num_embeddings
        self.embedding_size = embedding_size
        self.weight = weight
        self.dtype = dtype
        self.layer = eqx.nn.Embedding(num_embeddings=num_embeddings, embedding_size=embedding_size, weight=weight, dtype=dtype, key=key)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state

class Dropout(Component):
    """Dropout layer. Disabled by default in graph execution (inference mode)."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.Dropout
    p: float
    inference: bool
    deterministic: Optional[bool]
    def __init__(self, p: float = 0.5, inference: bool = False, deterministic: Optional[bool] = None):
        self.p = p
        self.inference = inference
        self.deterministic = deterministic
        self.layer = eqx.nn.Dropout(p=p, inference=inference, deterministic=deterministic)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = eqx.nn.inference_mode(self.layer)(inputs["input"])
        return {"output": output}, state

class PReLU(Component):
    """Parametric ReLU activation."""

    input_ports = ('input',)
    output_ports = ('output',)

    layer: eqx.nn.PReLU
    init_alpha: Union[float, Array, None]
    def __init__(self, init_alpha: Union[float, Array, None] = 0.25):
        self.init_alpha = init_alpha
        self.layer = eqx.nn.PReLU(init_alpha=init_alpha)

    def __call__(
        self,
        inputs: dict[str, PyTree],
        state: State,
        *,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, PyTree], State]:
        output = self.layer(inputs["input"])
        return {"output": output}, state
